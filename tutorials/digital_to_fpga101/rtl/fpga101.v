/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module fifo (
  input rd,
  input wr,
  input [7:0] D,
  input clk,
  input clr,
  output [7:0] Q,
  output full,
  output empty
);
  wire full_temp;
  wire empty_temp;
  wire s0;
  wire s1;
  wire [9:0] s2;
  wire [9:0] s3;
  wire [9:0] s4;
  wire [8:0] s5;
  wire [8:0] s6;
  assign s0 = (~ empty_temp & rd);
  assign s1 = (wr & ~ full_temp);
  // Read
  DIG_Counter_Nbit #(
    .Bits(10)
  )
  DIG_Counter_Nbit_i0 (
    .en( s0 ),
    .C( clk ),
    .clr( clr ),
    .out( s3 )
  );
  // Write
  DIG_Counter_Nbit #(
    .Bits(10)
  )
  DIG_Counter_Nbit_i1 (
    .en( s1 ),
    .C( clk ),
    .clr( clr ),
    .out( s2 )
  );
  bram bram_i2 (
    .addr_rd( s5 ),
    .addr_wr( s6 ),
    .clk( clk ),
    .en_wr( s1 ),
    .data_wr( D ),
    .data_rd( Q )
  );
  DIG_Sub #(
    .Bits(10)
  )
  DIG_Sub_i3 (
    .a( s2 ),
    .b( s3 ),
    .c_i( 1'b0 ),
    .s( s4 )
  );
  assign s5 = s3[8:0];
  assign s6 = s2[8:0];
  CompUnsigned #(
    .Bits(10)
  )
  CompUnsigned_i4 (
    .a( s4 ),
    .b( 10'b0 ),
    .\= ( empty_temp )
  );
  CompUnsigned #(
    .Bits(10)
  )
  CompUnsigned_i5 (
    .a( s4 ),
    .b( 10'b1000000000 ),
    .\= ( full_temp )
  );
  assign full = full_temp;
  assign empty = empty_temp;
endmodule

module equals_gen0 (
  input [7:0] A,
  input [7:0] B,
  output Q
);
  // =
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i0 (
    .a( A ),
    .b( B ),
    .\= ( Q )
  );
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module rsff (
  input S,
  input C,
  input R,
  output Q,
  output \~Q 
);
  wire Q_temp;
  wire s0;
  assign s0 = ((Q_temp | S) & ~ R);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( C ),
    .Q( Q_temp ),
    .\~Q ( \~Q  )
  );
  assign Q = Q_temp;
endmodule

module fsm (
  input [7:0] rx_data,
  input tx_busy,
  input tx_empty,
  input clk,
  input rx_empty,
  output xfer,
  output tx_start,
  output tx_rd
);
  wire xfer_temp;
  wire s0;
  wire tx_rd_temp;
  wire s1;
  wire s2;
  equals_gen0 equals_gen0_i0 (
    .A( rx_data ),
    .B( 8'b1010 ),
    .Q( s0 )
  );
  rsff rsff_i1 (
    .S( s0 ),
    .C( clk ),
    .R( rx_empty ),
    .Q( xfer_temp )
  );
  rsff rsff_i2 (
    .S( xfer_temp ),
    .C( clk ),
    .R( tx_empty ),
    .Q( s1 )
  );
  assign tx_rd_temp = (s1 & ~ tx_empty & ~ tx_busy);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s1 ),
    .C( clk ),
    .Q( s2 )
  );
  assign tx_start = (s2 & tx_rd_temp);
  assign xfer = xfer_temp;
  assign tx_rd = tx_rd_temp;
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module filt0 (
  input [7:0] I,
  output [7:0] O
);
  wire s0;
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i0 (
    .a( I ),
    .b( 8'b0 ),
    .\= ( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i1 (
    .sel( s0 ),
    .in_0( I ),
    .in_1( 8'b1010 ),
    .out( O )
  );
endmodule

module fpga101 (
  input rx,
  input clk,
  output tx
);
  wire C;
  wire s0;
  wire [7:0] s1;
  wire s2;
  wire [7:0] s3;
  wire s4;
  wire xfer;
  wire [7:0] rx_data;
  wire R;
  wire [7:0] QD;
  wire rx_empty;
  wire s5;
  wire s6;
  wire s7;
  pll pll_i0 (
    .clock_in( clk ),
    .clock_out( C ),
    .locked( s7 )
  );
  assign R = ~ s7;
  uart uart_i1 (
    .rx( rx ),
    .clk( C ),
    .tx_start( s0 ),
    .tx_data( s1 ),
    .tx( tx ),
    .rx_ready( s2 ),
    .rx_data( s3 ),
    .tx_busy( s4 )
  );
  // RX
  fifo fifo_i2 (
    .rd( xfer ),
    .wr( s2 ),
    .D( rx_data ),
    .clk( C ),
    .clr( R ),
    .Q( QD ),
    .empty( rx_empty )
  );
  // TX
  fifo fifo_i3 (
    .rd( s5 ),
    .wr( xfer ),
    .D( QD ),
    .clk( C ),
    .clr( R ),
    .Q( s1 ),
    .empty( s6 )
  );
  fsm fsm_i4 (
    .rx_data( rx_data ),
    .tx_busy( s4 ),
    .tx_empty( s6 ),
    .clk( C ),
    .rx_empty( rx_empty ),
    .xfer( xfer ),
    .tx_start( s0 ),
    .tx_rd( s5 )
  );
  filt0 filt0_i5 (
    .I( s3 ),
    .O( rx_data )
  );
endmodule
